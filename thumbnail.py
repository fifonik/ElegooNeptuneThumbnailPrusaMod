#!/usr/bin/env python3

# Copyright (c) 2025 fifonik
# Copyright (c) 2023 TheJMaster28
# Copyright (c) 2023 Molodos
# Copyright (c) 2023 sigathi
# Copyright (c) 2020 DhanOS
# The ElegooNeptuneThumbnailPrusaMod plugin is released under the terms of the AGPLv3 or higher.


import argparse
import base64
import logging
import re
import sys

from array import array
from ctypes import *
from io import BytesIO
from os import path, replace

from PyQt6.QtCore import Qt, QRect, QRectF, QByteArray, QBuffer, QIODeviceBase
from PyQt6.QtGui import QColor, QFont, QGuiApplication, QImage, QPainter

import lib_col_pic

script_dir = path.dirname(sys.argv[0])
log_file = path.join(script_dir, path.splitext(sys.argv[0])[0] + '.log')
logging.basicConfig(level=logging.DEBUG, filename=log_file, filemode="w", format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)
app = QGuiApplication(sys.argv)



def myround(value: float, divider=1) -> str:
    f = value / divider
    if abs(f) < 10:
        return str(round(f, 1));
    else:
        return str(round(f));



def extract_value(line: str, key: str) -> str:
    p = line.find(key)
    if p < 0:
        return ''
    pv = p + len(key);
    p2 = line.find(';', pv)
    if p2 >= 0:
        return line[pv:p2].strip()
    else:
        return line[pv:].strip()



def parse_multi_items_value(value: str) -> float:
    result = 0.0
    for s in value.split(','):
        try:
            result += float(s.strip())
        except Exception as ex:
            logger.info('parse_multi_items_value: cannot convert to float=' + s)
    return result



def draw_text(painter: QPainter, rect: QRect, text: str, flags: int, color: QColor = QColor(Qt.GlobalColor.white), bgcolor: QColor = None):
    if bgcolor is not None:
        boundingRect = painter.boundingRect(rect, flags, text)
        painter.fillRect(QRectF(boundingRect), bgcolor)
    painter.setPen(color)
    painter.drawText(rect, flags, text)


def join(items) -> str:
    result = ''
    for item in items:
        if result != '':
            result += ','
        if item is not None:
            result += item
        else:
            result += 'blank'
    return result


class Neptune_Thumbnail:
    def __init__(self, args):
        self.currency = args.currency
        self.currency_suffix = args.currency_suffix
        self.debug = args.debug
        self.filament_cost = None
        self.filament_used_weight = None
        self.filament_used_length = None
        self.header = ''
        self.header_line = None
        self.input_file = args.input_file
        self.img_base64_block_len = 78
        self.img_encoded = ''
        self.img_encoded_begin = None
        self.img_encoded_end = None
        self.img_size = args.image_size
        self.img_type = None
        self.img_type_detected = None
        self.img_width = None
        self.img_height = None
        self.images = args.images
        self.info = self.parse_info(args.info)
        self.max_height = 0
        self.modify_slicer_header = args.modify_slicer_header
        self.original_image_light_theme = args.original_image_light_theme
        self.print_duration = None
        self.print_duration_short_format = args.short_duration_format
        self.run_old_printer = args.old_printer
        self.slicer_mask_regex = re.compile(r'(Prusa|Orca)(Slicer)')
        self.update_original_image = args.update_original_image

        logger.info(f'Input file: {self.input_file}')
        if self.img_size is None:
            logger.info('The first thumbnail from input file larger than 100x100 will be used')
        else:
            logger.info(f'Will try to find thumbnail with specified size: {self.img_size}')
        logger.info('Adding info icons: ' + join(self.info))
        if self.print_duration_short_format:
            logger.info('Using short time format for pringing duration')
        if self.run_old_printer:
            logger.info('Using older printer settings')
        if not self.run_old_printer and self.images != None:
            logger.info('Generating previews in this order: ' + self.images)
        if self.update_original_image:
            logger.info('Updating original image')
        if self.modify_slicer_header:
            logger.info('Modifying slicer header (WARNING: this will break gcode viewers and fluidd files properties)')



    def log_debug(self, s: str):
        if self.debug:
            logger.debug(s)



    def parse(self):
        self.log_debug('Parsing file')

        img_size_regex = re.compile(r'(?P<size>(?P<width>\d+)x(?P<height>\d+))')
        img_end_token = '; thumbnail end'
        img_size = self.img_size
        with open(self.input_file, 'r', encoding='utf8') as input:
            for index, line in enumerate(input):
                if line.startswith('; generated by '):
                    self.header = line
                    self.header_line = index
                    self.log_debug(f'"generated by" found at line {index}')
                elif 'estimated printing time (normal mode) =' in line:
                    self.print_duration = extract_value(line, 'estimated printing time (normal mode) =')
                    self.log_debug(f'Print duration "{self.print_duration}" found at line {index}')
                elif 'total filament used [g] =' in line:
                    self.filament_used_weight = parse_multi_items_value(extract_value(line, 'total filament used [g] ='))
                    self.log_debug(f'Filament used [g] "{self.filament_used_weight}" found at line {index}')
                elif 'filament used [mm] =' in line:
                    self.filament_used_length = parse_multi_items_value(extract_value(line, 'filament used [mm] ='))
                    self.log_debug(f'Filament used [mm] "{self.filament_used_length}" found at line {index}')
                elif 'total filament cost =' in line:
                    self.filament_cost = float(extract_value(line, 'total filament cost ='))
                    self.log_debug(f'Filament cost "{self.filament_cost}" found at line {index}')
                elif line.startswith(';Z:'):
                    value = line.split(':')
                    height = float(value[1].strip())
                    if height > self.max_height:
                        self.max_height = height
                elif line.startswith('; thumbnail') and ' begin' in line:
                    found = False
                    if self.img_size is None:
                        m = img_size_regex.search(line)
                        if m is not None and int(m.group('width')) >= 100 and int(m.group('height')) >= 100:
                            found = True
                            self.img_size = m.group('size')
                    elif f' {self.img_size} ' in line:
                        found = True
                    if found:
                        _ = self.img_size.split('x')
                        self.img_width = int(_[0])
                        self.img_height = int(_[1])
                        self.img_encoded_begin = index
                        if 'thumbnail_JPG' in line:
                            self.img_type = 'JPG'
                            img_end_token = '; thumbnail_JPG end'
                        self.log_debug(f'{self.img_type} thumbnail begin found at line {index}')
                elif self.img_encoded_begin is not None and self.img_encoded_end is None and line.startswith(img_end_token):
                    self.img_encoded_end = index
                    self.log_debug(f'{self.img_type} thumbnail end found at line {index}')
                elif self.img_encoded_begin is not None and self.img_encoded_end is None:
                    self.img_encoded += line.strip('; ')
                if self.print_duration is not None and self.filament_cost is not None and self.filament_used_length is not None and self.filament_used_weight is not None and self.img_encoded_begin is not None and self.img_encoded_end is not None:
                    return

            if img_size is not None:
                # Show error cause by "thumbnail not found" only if size was specified in options
                if self.img_encoded_begin is None:
                    raise Exception(f'Thumbnail begin not found in {self.input_file}')
                if self.img_encoded_begin is not None and self.img_encoded_end is None:
                    raise Exception(f'Thumbnail end not found in {self.input_file}')



    def parse_info(self, info: str) -> str:
        result = [None, None, None, None]
        supported = ['print_duration', 'model_height', 'filament_weight', 'filament_length', 'filament_cost']
        if info is not None:
            items = info.lower().split(',')
            i = 0
            for item in items:
                if item.lower() in supported:
                    result[i] = item
                i += 1
        return result



    def image_decode(self, text) -> QImage:
        """
        Decodes base64 encoded image to QImage
        """
        if not text:
            raise Exception('Thumbnail text is empty')

        self.log_debug('Decoding thumbnail from base64')
        text_bytes = text.encode('ascii')
        decode_data = base64.b64decode(text_bytes)
        image_stream = BytesIO(decode_data)
        img: QImage = QImage.fromData(image_stream.getvalue())

        self.img_type_detected = 'PNG'
        if img.format() != QImage.Format.Format_ARGB32:
            self.img_type_detected = 'JPG'
            img = img.convertToFormat(QImage.Format.Format_ARGB32)

        return img



    def image_resize(self, img: QImage, width, height) -> QImage:
        """
        Resize image
        """
        if img is None:
            raise Exception('No image')

        img_size = img.size()
        if img_size.width() == width and img_size.height() == height:
            return QImage(img);

        self.log_debug(f'Scaling image to {width}x{height}')
        return img.scaled(width, height, Qt.AspectRatioMode.KeepAspectRatio)



    def image_modify(self, img: QImage, light_theme: bool=False) -> QImage:
        """
        Add texts to image
        """
        if self.filament_cost is None and self.filament_used_length and self.filament_used_weight is None and self.max_height > 0 is None and self.print_duration is None:
            return img;

        img_size = img.size()
        self.log_debug(f'Adding texts to image {img_size.width()}x{img_size.height()}')

        font_size = int(img_size.height() / 14);

        rect_top = QRect(0, 0, img_size.width(), int(img_size.height() / 2) - 1)
        rect_bottom = QRect(0, int(img_size.height() / 2), img_size.width(), int(img_size.height() / 2))

        font = QFont('Arial', font_size)
        font.setStyleHint(QFont.StyleHint.AnyStyle, QFont.StyleStrategy.ForceOutline)

        bgcolor = None
        if light_theme:
            color = QColor(Qt.GlobalColor.black)
            #bgcolor = QColor(Qt.GlobalColor.white)
        else:
            color = QColor(Qt.GlobalColor.white)
            #bgcolor = QColor(Qt.GlobalColor.black)

        painter = QPainter()
        painter.begin(img)

        painter.setFont(font)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        for i in range(4):
            if self.info[i] is None:
                continue

            position: int = None
            rect: QRect = None
            match i:
                case 0:
                    position = Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop
                    rect = rect_top
                case 1:
                    position = Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignTop
                    rect = rect_top
                case 2:
                    position = Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignBottom
                    rect = rect_bottom
                case 3:
                    position = Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignBottom
                    rect = rect_bottom

            text: str = None
            match self.info[i]:
                case 'filament_cost':
                    if self.filament_cost is not None:
                        text = '{:.1f}'.format(round(self.filament_cost, 1))
                        if self.currency_suffix:
                            text = text + self.currency
                        else:
                            text = self.currency + text

                case 'filament_length':
                    if self.filament_used_length is not None:
                        text = '\U0001F826' + myround(self.filament_used_length, 1000) + 'm'

                case 'filament_weight':
                    if self.filament_used_weight is not None:
                        # todo@ find better char
                        text = '\U0001F847' + myround(self.filament_used_weight) + 'g'

                case 'model_height':
                    if self.max_height > 0:
                        text = '\u2912' + '{:.1f}'.format(round(self.max_height, 1)) + 'mm'

                case 'print_duration':
                    if self.print_duration is not None:
                        if self.print_duration_short_format:
                            def repl(m):
                                s = m.group(1)
                                if s is None:
                                    return ''
                                match m.group(2):
                                    case 'd':
                                        return s + m.group(2) + 'd '
                                    case 's':
                                        return ''
                                return ':' + '{:02d}'.format(int(s))
                            s = re.sub(r'\s*(\d+)\s*([dhms])', repl, self.print_duration)
                            s = s.replace(' :', ' ').strip(': ')
                            if ':' not in s:
                                s = '00:' + s
                            text = '\u25F7' + s
                        else:
                            text = '\u29D6' + self.print_duration

            if text is None:
                continue

            draw_text(painter, rect, text, position, color, bgcolor)

        painter.end()

        if self.debug:
            img_type = self.img_type
            if img_type is None:
                img_type = 'PNG'
            img.save(path.join(script_dir, 'img-' + str(img_size.width()) + 'x' + str(img_size.height()) + '.' + img_type.lower()))

        return img



    def image_encode(self, img: QImage, prefix) -> str:
        """
        Encode image for old printers
        """
        if img is None:
            raise Exception('No image')

        self.log_debug(f'Encoding image for old printers ({prefix})')
        result = ''
        img_size = img.size()
        width = img_size.width()
        height = img_size.height()
        result += prefix
        datasize = 0
        for i in range(height):
            for j in range(width):
                pixel_color = img.pixelColor(j, i)
                r = pixel_color.red() >> 3
                g = pixel_color.green() >> 2
                b = pixel_color.blue() >> 3
                rgb = (r << 11) | (g << 5) | b
                str_hex = '%x' % rgb
                match len(str_hex):
                    case 3:
                        str_hex = '0' + str_hex[0:3]
                    case 2:
                        str_hex = '00' + str_hex[0:2]
                    case 1:
                        str_hex = '000' + str_hex[0:1]
                if str_hex[2:4] != '':
                    result += str_hex[2:4]
                    datasize += 2
                if str_hex[0:2] != '':
                    result += str_hex[0:2]
                    datasize += 2
                if datasize >= 50:
                    datasize = 0
            result += '\rM10086 ;'
            if i == height - 1:
                result += '\r'
        return result



    def image_encode_new(self, img: QImage, prefix) -> str:
        """
        Encode image for new printers
        """
        if img is None:
            raise Exception('No image to encode')

        self.log_debug(f'Encoding image for new printers with prefix: {prefix}')

        result   = ''
        img_size = img.size()
        width    = img_size.width()
        height   = img_size.height()
        color16  = array('H')
        try:
            for i in range(height):
                for j in range(width):
                    pixel_color = img.pixelColor(j, i)
                    r = pixel_color.red() >> 3
                    g = pixel_color.green() >> 2
                    b = pixel_color.blue() >> 3
                    rgb = (r << 11) | (g << 5) | b
                    color16.append(rgb)

            buffer_size       = height * width * 10
            buffer            = bytearray(buffer_size)
            encoded_size      = int(lib_col_pic.ColPic_EncodeStr(color16, width, height, buffer, buffer_size, 1024))

            if encoded_size <= 0:
                raise Exception(f'Nothing encoded')

            prefix_len        = len(prefix)
            max_line_len      = 1024
            max_line_data_len = max_line_len - prefix_len - 1

            data              = buffer[:encoded_size]
            data_len          = len(data)
            lines_count       = int(data_len / max_line_data_len)
            append_len        = max_line_data_len - 3 - int(data_len % max_line_data_len)

            #logger.debug(f'image_encode_new: encoded_size={encoded_size} data_len={data_len} lines_count={lines_count} append_len={append_len}')
            #logger.debug(f'buffer={str(buffer)}')
            #logger.debug(f'  data={str(data)}')

            for i in range(data_len):
                if i % max_line_data_len == 0:
                    if i > 0:
                        result += '\r'
                        if i == lines_count * max_line_data_len:
                            # last line should be ';;gimage:', instead of ';gimage:'
                            result += ';'
                    result += prefix
                result += chr(data[i])

            result += '\r;' + ('0' * append_len)

        except Exception:
            logger.exception('Failed to encode new thumbnail')

        return result + '\r'



    def image_encode_klipper(self, img: QImage, img_type: str, base64_block_len: int) -> str:
        """
        Generate image in original Klipper format (base64 with prefix & suffix)
        """
        result: str = '\n'
        byte_array: QByteArray = QByteArray()
        byte_buffer: QBuffer = QBuffer(byte_array)
        byte_buffer.open(QIODeviceBase.OpenModeFlag.WriteOnly)
        img.save(byte_buffer, img_type)
        base64: str = str(byte_array.toBase64().data(), "UTF-8")
        base64_len: int = len(base64)
        result += f'; thumbnail begin {img.width()}x{img.height()} {base64_len}\n'
        pos: int = 0
        while pos < base64_len:
            result += f'; {base64[pos:pos+base64_block_len]}\n'
            pos += base64_block_len
        result += f'; thumbnail end\n\n'
        return result



    def slicer_header(self) -> str:
        result = ''
        if self.modify_slicer_header:
            result += re.sub(self.slicer_mask_regex, r'\1-\2', self.header);
            # Seeing this works for N4 printer thanks to Molodos: https://github.com/Molodos/ElegooNeptuneThumbnails-Prusa
            result += '\n; Mentioning Cura_SteamEngine X.X to trick printer into thinking this is Cura\n'
            result += '; Unfortunately, this "Cura stuff" is breaking Prusa/Orca gcode viewer and fluidd might not show some info\n\n'
        else:
            result += self.header
        return result



    def run(self):
        """
        Main runner for executable
        """
        self.parse()

        if not self.img_encoded:
            logger.info('Thumbnail not found in g-code')
            return;

        self.log_debug('Modifying g-code file')

        img = self.image_decode(self.img_encoded)
        if self.update_original_image:
            img_klipper = self.image_encode_klipper(self.image_modify(QImage(img), self.original_image_light_theme), self.img_type_detected, self.img_base64_block_len)

        images = ''
        if self.run_old_printer:
            images += self.image_encode(self.image_modify(self.image_resize(img, 100, 100)), ';simage:')
            images += self.image_encode(self.image_modify(self.image_resize(img, 200, 200)), ';gimage:')
        else:
            formats = [];
            if self.images != None:
                img_props_regex = re.compile(r'(?P<width>\d+)x(?P<height>\d+)/(?P<type>\w+)')
                for format in self.images.split(','):
                    try:
                        parsed = img_props_regex.search(format.strip())
                        if parsed is not None:
                            formats.append({
                                'width': int(parsed.group('width')),
                                'height': int(parsed.group('height')),
                                'type': parsed.group('type')
                            });
                    except Exception as ex:
                        logger.info(f'Unable to parse image format: {format}')
            if len(formats) == 0:
                formats = [
                    {'width': 200, 'height': 200, 'type': 'gimage'},
                    {'width': 160, 'height': 160, 'type': 'simage'}
                ];
            formats_string = ''
            for format in formats:
                formats_string += ' ' + str(format['width']) + 'x' + str(format['height']) + '/' + format['type'];
            self.log_debug(f'Images to be generated: {formats_string}')
            for format in formats:
                images += self.image_encode_new(self.image_modify(self.image_resize(img, format['width'], format['height'])), ';' + format['type'] + ':')
        images += '\n\n; Thumbnail Generated by ElegooNeptuneThumbnailPrusaMod\n'

        output_file = self.input_file + '.output'
        with open(self.input_file, 'r', encoding='utf8') as input, open(output_file, 'w', encoding='utf8') as output:
            self.log_debug(f'Writing new header with image into file {output_file}')
            # Adding image at the very beginning as comments before image breaks it on some neptune printers
            output.write(images)
            self.log_debug(f'Copying content from file {self.input_file} to file {output_file}')
            time_elapsed = None
            total_duration = None
            for index, line in enumerate(input):
                if index == self.header_line:
                    output.write(self.slicer_header())
                    continue
                if self.update_original_image:
                    if index > self.img_encoded_begin and index <= self.img_encoded_end:
                        continue
                    if index == self.img_encoded_begin:
                        output.write(img_klipper)
                        continue
                if time_elapsed is not None and line.startswith(';LAYER_CHANGE'):
                    output.write(';TIME_ELAPSED:' + str(time_elapsed) + '\n');
                if line.startswith('M73 P'):
                    # Converting 'M73 P<percentage-completed> R<time-left-in-minutes>' to ';TIME:<print-duration-in-seconds>' + ';TIME_ELAPSED:<time-elapsed-in-seconds>'
                    (percentage, time_to_end) = line[5:].split(' R')
                    t = int(time_to_end) * 60
                    if total_duration is None:
                        total_duration = t
                        output.write(';TIME:' + str(total_duration) + '\n')
                        self.log_debug(f'Progress: {percentage}% complete (total duration: {t} seconds)')
                    else:
                        time_elapsed = total_duration - t
                        self.log_debug(f'Progress: {percentage}% complete, {time_elapsed} seconds passed')
                output.write(line)

        if path.isfile(output_file):
            self.log_debug(f'Renaming file {output_file} to {self.input_file}')
            replace(output_file, self.input_file)
        else:
            raise Exception(f'File {output_file} does not exists')

        logger.info('G-code file modification completed')


if __name__ == '__main__':
    try:
        parser = argparse.ArgumentParser(prog=path.basename(__file__))
        parser.add_argument(
            'input_file',
            metavar='gcode-files',
            type=str,
            help='G-code file to be processed',
        )
        parser.add_argument(
            '--old_printer',
            help='Run for older Neptune Printers',
            default=False,
            action='store_true',
        )
        parser.add_argument(
            '--images',
            default=None,
            help='Images that will be generated for new printers in specified order. Default: 200x200;simage,160x160;simage',
        )
        parser.add_argument(
            '--image_size',
            default=None,
            help='Size of image to find in G-code file to encode (the first thumbnail will be used if this option is not specified)',
        )
        parser.add_argument(
            '--short_duration_format',
            default=False,
            action='store_true',
            help='Use short print duration format (DDd HH:MM)',
        )
        parser.add_argument(
            '--update_original_image',
            default=False,
            action='store_true',
            help='Inject additional information into original image',
        )
        parser.add_argument(
            '--original_image_light_theme',
            default=False,
            action='store_true',
            help='Original image should be modified for light Klipper theme',
        )
        parser.add_argument(
            '--modify_slicer_header',
            default=True,
            action=argparse.BooleanOptionalAction,
            help='Cura header will be added and original slicer will be masked',
        )
        parser.add_argument(
            '--debug',
            default=False,
            action='store_true',
            help='Output image and write additional info into log file',
        )
        parser.add_argument(
            '--info',
            default='print_duration,model_height,filament_weight,filament_length',
            help='Comma separated list of info icons that will be added on images',
        )
        parser.add_argument(
            '--currency',
            default='$',
            help='Currency',
        )
        parser.add_argument(
            '--currency_suffix',
            default=False,
            action='store_true',
            help='Add currency as suffix',
        )

        args = parser.parse_args()
        obj = Neptune_Thumbnail(args)
        obj.run()
    except Exception as ex:
        logger.exception('Error occurred while running application')



# Python sux. I hate it.
